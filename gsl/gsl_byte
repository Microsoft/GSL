///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
//
// This code is licensed under the MIT License (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef GSL_BYTE_H
#define GSL_BYTE_H

#ifdef _MSC_VER

#pragma warning(push)

// don't warn about function style casts in byte related operators
#pragma warning(disable : 26493)

// MSVC 2013 workarounds
#if _MSC_VER <= 1800

// constexpr is not understood
#pragma push_macro("constexpr")
#define constexpr /*constexpr*/

// noexcept is not understood
#pragma push_macro("noexcept")
#define noexcept /*noexcept*/

#endif // _MSC_VER <= 1800

#endif // _MSC_VER

#define GSL_BYTE_TYPE_ENUM 0
#define GSL_BYTE_TYPE_UCHAR 1
#define GSL_BYTE_TYPE_STRUCT 2

#ifndef GSL_USE_BYTE_TYPE
// currently clang++ as well as g++ don't allow a pointer to
//
// < enum class byte : unsigned char >
//
// to alias other types.
// so we have to use a typedef to unsigned char instead.
#ifdef _MSC_VER
    #define GSL_USE_BYTE_TYPE GSL_BYTE_TYPE_ENUM
#else
    #define GSL_USE_BYTE_TYPE GSL_BYTE_TYPE_STRUCT
#endif

#endif

namespace gsl
{
//################################### implemet byte as unsigned char ####################################
#if GSL_USE_BYTE_TYPE == GSL_BYTE_TYPE_UCHAR

using byte = unsigned char;

template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr IntegerType to_integer(byte b) noexcept
{
    return{ b };
}

template<bool E, typename T>
inline constexpr byte to_byte_impl(T t) noexcept
{
    static_assert(
        E,
        "gsl::to_byte(t) must be provided an unsigned char, otherwise data loss may occur. "
        "If you are calling to_byte with an integer contant use: gsl::to_byte<t>() version."
        );
    return static_cast<byte>(t);
}

template<>
inline constexpr byte to_byte_impl<true, unsigned char>(unsigned char t) noexcept
{
    return byte(t);
}

template<typename T>
inline constexpr byte to_byte(T t) noexcept
{
    return to_byte_impl<std::is_same<T, unsigned char>::value, T>(t);
}

template <int I>
inline constexpr byte to_byte() noexcept
{
    static_assert(I >= 0 && I <= 255, "gsl::byte only has 8 bits of storage, values must be in range 0-255");
    return static_cast<byte>(I);
}

//################################### implemet byte as struct ####################################

#elif GSL_USE_BYTE_TYPE == GSL_BYTE_TYPE_STRUCT

// This is a simple definition for now that allows
// use of byte within span<> to be standards-compliant
struct byte {
    unsigned char v;
    explicit operator unsigned char&() { return v; }
    explicit operator const unsigned char&() const { return v; }
    friend bool operator==(byte l, byte r) { return l.v == r.v; }
    friend bool operator!=(byte l, byte r) { return l.v != r.v; }
};

template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr byte& operator<<=(byte& b, IntegerType shift) noexcept
{
    return b.v <<= shift, b;
}

template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr byte operator<<(byte b, IntegerType shift) noexcept
{
    return byte{ static_cast<unsigned char>(b.v << shift) };
}

template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr byte& operator>>=(byte& b, IntegerType shift) noexcept
{
    return b.v >>= shift, b;
}

template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr byte operator >> (byte b, IntegerType shift) noexcept
{
    return byte{ static_cast<unsigned char>(b.v >> shift) };
}

inline constexpr byte& operator|=(byte& l, byte r) noexcept
{
    return  l.v |= r.v, l;
}

inline constexpr byte operator|(byte l, byte r) noexcept
{
    return byte{ static_cast<unsigned char>(l.v | r.v) };
}

inline constexpr byte& operator&=(byte& l, byte r) noexcept
{
    return  l.v &= r.v, l;
}

inline constexpr byte operator&(byte l, byte r) noexcept
{
    return byte{ static_cast<unsigned char>(l.v & r.v) };
}

inline constexpr byte& operator^=(byte& l, byte r) noexcept
{
    return  l.v ^= r.v, l;
}

inline constexpr byte operator^(byte l, byte r) noexcept
{
    return byte{ static_cast<unsigned char>(l.v ^ r.v) };
}

inline constexpr byte operator~(byte b) noexcept { return byte{ static_cast<unsigned char>(~b.v) }; }


template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr IntegerType to_integer(byte b) noexcept
{
    return static_cast<IntegerType>(b.v);
}

template<typename T>
inline constexpr byte to_byte(T t) noexcept
{
    static_assert(
        std::is_same<T, unsigned char>::value,
        "gsl::to_byte(t) must be provided an unsigned char, otherwise data loss may occur. "
        "If you are calling to_byte with an integer contant use: gsl::to_byte<t>() version."
        );
    return byte{ t };
}

template <int I>
inline constexpr byte to_byte() noexcept
{
    static_assert(I >= 0 && I <= 255, "gsl::byte only has 8 bits of storage, values must be in range 0-255");
    return byte{ static_cast<unsigned char>(I) };
}

//################################### implemet byte as enum ####################################

#elif GSL_USE_BYTE_TYPE == GSL_BYTE_TYPE_ENUM

// This is a simple definition for now that allows
// use of byte within span<> to be standards-compliant
enum class byte : unsigned char
{
};

template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr byte& operator<<=(byte& b, IntegerType shift) noexcept
{
    return b = byte(static_cast<unsigned char>(b) << shift);
}

template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr byte operator<<(byte b, IntegerType shift) noexcept
{
    return byte(static_cast<unsigned char>(b) << shift);
}

template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr byte& operator>>=(byte& b, IntegerType shift) noexcept
{
    return b = byte(static_cast<unsigned char>(b) >> shift);
}

template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr byte operator>>(byte b, IntegerType shift) noexcept
{
    return byte(static_cast<unsigned char>(b) >> shift);
}

inline constexpr byte& operator|=(byte& l, byte r) noexcept
{
    return l = byte(static_cast<unsigned char>(l) | static_cast<unsigned char>(r));
}

inline constexpr byte operator|(byte l, byte r) noexcept
{
    return byte(static_cast<unsigned char>(l) | static_cast<unsigned char>(r));
}

inline constexpr byte& operator&=(byte& l, byte r) noexcept
{
    return l = byte(static_cast<unsigned char>(l) & static_cast<unsigned char>(r));
}

inline constexpr byte operator&(byte l, byte r) noexcept
{
    return byte(static_cast<unsigned char>(l) & static_cast<unsigned char>(r));
}

inline constexpr byte& operator^=(byte& l, byte r) noexcept
{
    return l = byte(static_cast<unsigned char>(l) ^ static_cast<unsigned char>(r));
}

inline constexpr byte operator^(byte l, byte r) noexcept
{
    return byte(static_cast<unsigned char>(l) ^ static_cast<unsigned char>(r));
}

inline constexpr byte operator~(byte b) noexcept { return byte(~static_cast<unsigned char>(b)); }

template <class IntegerType, class = std::enable_if_t<std::is_integral<IntegerType>::value>>
inline constexpr IntegerType to_integer(byte b) noexcept
{
    return static_cast<IntegerType>(b);
}

template<bool E, typename T>
inline constexpr byte to_byte_impl(T t) noexcept
{
    static_assert(
        E,
        "gsl::to_byte(t) must be provided an unsigned char, otherwise data loss may occur. "
        "If you are calling to_byte with an integer contant use: gsl::to_byte<t>() version."
    );
    return static_cast<byte>(t);
}
template<>
inline constexpr byte to_byte_impl<true, unsigned char>(unsigned char t) noexcept
{
     return byte(t);
}

template<typename T>
inline constexpr byte to_byte(T t) noexcept
{
     return to_byte_impl<std::is_same<T, unsigned char>::value, T>(t);
}

template <int I>
inline constexpr byte to_byte() noexcept
{
    static_assert(I >= 0 && I <= 255, "gsl::byte only has 8 bits of storage, values must be in range 0-255");
    return static_cast<byte>(I);
}
#endif // GSL_USE_ENUM_BYTE

} // namespace gsl

#ifdef _MSC_VER

#if _MSC_VER <= 1800

#undef constexpr
#pragma pop_macro("constexpr")

#undef noexcept
#pragma pop_macro("noexcept")

#endif // _MSC_VER <= 1800

#pragma warning(pop)

#endif // _MSC_VER

#endif // GSL_BYTE_H
