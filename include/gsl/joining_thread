///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
//
// This code is licensed under the MIT License (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef GSL_JOINING_THREAD_H
#define GSL_JOINING_THREAD_H

#include <memory>
#include <thread>
#include <utility>

namespace gsl
{
/**
 * RAII wrapper for std::thread.
 * It's guaranteed that joining_thread will join when destructed.
 */
class joining_thread
{
    using JoiningThreadUPtr = std::unique_ptr<std::thread, std::function<void(std::thread*)>>;
    template <typename... Args>
    JoiningThreadUPtr create_thread_with_joining_deleter(Args&&... args)
    {
        return {new std::thread(std::forward<Args>(args)...), [](auto* th) { th->join(); }};
    }

public:
    template <class Function, class... Args>
    explicit joining_thread(Function&& function, Args&&... args)
        : thread{create_thread_with_joining_deleter(std::forward<Function>(function),
                                                    std::forward<Args>(args)...)}
    {
    }

    std::thread::id get_id() const noexcept { return (*thread).get_id(); }

    std::thread::native_handle_type native_handle() { return (*thread).native_handle(); }

    static unsigned int hardware_concurrency() noexcept
    {
        return std::thread::hardware_concurrency();
    }

    void swap(joining_thread&& other) noexcept
    {
        using std::swap;
        swap(thread, other.thread);
    }

private:
    JoiningThreadUPtr thread;
};
}

namespace std
{
inline void swap(gsl::joining_thread& x, gsl::joining_thread& y) noexcept { x.swap(std::move(y)); }

inline void swap(gsl::joining_thread&& x, gsl::joining_thread& y) noexcept { x.swap(std::move(y)); }

inline void swap(gsl::joining_thread& x, gsl::joining_thread&& y) noexcept { x.swap(std::move(y)); }
}

#endif
