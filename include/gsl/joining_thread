///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
//
// This code is licensed under the MIT License (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef GSL_JOINING_THREAD_H
#define GSL_JOINING_THREAD_H

#include <thread>
#include <utility>

namespace gsl
{
/**
 * RAII wrapper for std::thread.
 * It's guaranteed that joining_thread will join started thread when destroyed.
 */
class joining_thread
{
public:
    joining_thread() noexcept {};

    template <class Function, class... Args>
    explicit joining_thread(Function&& function, Args&&... args)
        : thread(std::forward<Function>(function), std::forward<Args>(args)...)
    {
    }

    joining_thread(const joining_thread&) = default;
    joining_thread& operator=(const joining_thread&) = default;

    joining_thread(joining_thread&&) noexcept = default;
    joining_thread& operator=(joining_thread&&) noexcept = default;

    ~joining_thread()
    {
        if (thread.joinable()) { thread.join(); }
    }

    std::thread::id get_id() const noexcept { return thread.get_id(); }

    std::thread::native_handle_type native_handle() { return thread.native_handle(); }

    static unsigned int hardware_concurrency() noexcept
    {
        return std::thread::hardware_concurrency();
    }

    void swap(joining_thread&& other) noexcept
    {
        using std::swap;
        swap(thread, other.thread);
    }

private:
    std::thread thread;
};
}

namespace std
{
inline void swap(gsl::joining_thread& x, gsl::joining_thread& y) noexcept { x.swap(std::move(y)); }

inline void swap(gsl::joining_thread&& x, gsl::joining_thread& y) noexcept { x.swap(std::move(y)); }

inline void swap(gsl::joining_thread& x, gsl::joining_thread&& y) noexcept { x.swap(std::move(y)); }
}

#endif
